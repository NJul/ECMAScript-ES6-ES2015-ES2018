// Ключевые слова let и const
/* let нужно использовать только если значение действительно нужно менять. Иначе лучше использовать const */
let name = 'Joe';
name = 'Bob';
const pi = 3.14;

// Но мы можем изменять содержимое массива
/* let const видны только в рамках кода, где они объявлены, var - во всей функции видна */
const names = ['Peter', 'Bob'];
names.push('Jenny');
console.log(names);

/* Мы не можем присваивать новое значение объекту с const, но можем менять значения этого оъекта */
const person = {
  name: 'Joe',
  age: 25
};

person.name = 'Bob';

if (true) {
  let a = 1;
}
// Здесь переменнная a уже не видна, в каждой итерации let создается новая область памяти для переменной

for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i)
  }, i * 100);
}

/* В JavaScript функция является объектом */
function square(x) {
  return x * x;
}

// Arrow - функции
const sq = (x) => x * x;
// Если функция принимает один аргумент, можно убрать круглые скобки, но скобки лучше ставить
// const sq = x => x * x;
// Сколько будет 3 в квадрате
console.log(sq(3));


const arr = ['1', '3', '2', '4'];
/* Посмотрим, как при помощи функции стрелок можно преобразовать этот массив строк в числа, а затем найти максимальное нечетное число. */
/* Преобразуем массив строк в массив чисел .map((el) => parseInt(el)) используем функцию .map . (el) элемент массива .map возвращает этот же элемент только уже в виде числа */
/* Оставим в этом массиве только нечетные числа, отфильтровав четные, которые вернут true, останутся, остальные уйдут, 0 вернтет false
Функция стрелка примет число, и если остаток от деления этого числа на 2 равно что-нибудь, значит его стоит оставить, (num) => num % 2 */
/* Находим максимальное значение внутри этого массива */
const res = arr
  .map((el) => parseInt(el))
  .filter((num) => num % 2)
  .reduce((max, value) => Math.max(max, value), 0);

console.log(res);

const sq2 = (x) => {
  return x * x;
};

/* 
Функции стрелок сохраняют лексическое значение ключевого слова this
У функции стрелок нет свойства prototype Person.prototype, не могут быть вызваны с "new"
Из функции стрелки нельзя создавать новые объекты
Функции стрелки это легковесные версии обычных функций
*/

const greeter = {
  greet: function (name) {
    console.log('Hello', name);
  },
  greetAll: function (names) {
    names.forEach((name) => {
      this.greet(name);
    });
  }
};

greeter.greetAll(['Bob', 'Mark', 'Pete']);